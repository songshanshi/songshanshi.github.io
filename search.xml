<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tages]]></title>
    <url>%2F2019%2F07%2F28%2Ftages%2Findex%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo博客迁移记录]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%AE%89%E8%A3%85hexo%2F</url>
    <content type="text"><![CDATA[本文并不是从头开始搭建hexo博客的教程，而是因为最近个人重装了电脑系统，需求迁移原来搭建好的hexo博客，为了防止将来还需要迁移，特记录下操作流程，以便将来查看。 迁移博客的工作量要比从头开始搭建简单很多，很多插件的服务端配置都不需要重新设置，只需要在本地做相应的操作即可。 安装hexo第一步当然是安装相应的软件和配置好环境。需要安装的软件有Node.js和Git,去官网下载安装即可。 123git -vnode -vhexo -v 当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：1sudo npm install -g hexo git更换源12npm config set registry https://registry.npm.taobao.org npm info underscore (输出正常反馈信息则说明换源成功) hexo部署插件12345678本地测试的时候需要用hexo servernpm i hexo-server将文章部署到github上的模块npm install hexo-deployer-git --save安装RSS插件npm install hexo-generator-feed --save添加Sitemap,加速网页收录速度npm install hexo-generator-sitemap --save .deploy：执行hexo deploy命令部署到GitHub上的内容目录public：执行hexo generate命令，输出的静态网页内容目录scaffolds：layout模板文件目录，其中的md文件可以添加编辑scripts：扩展脚本目录，这里可以自定义一些javascript脚本source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。_drafts：草稿文章_posts：发布文章themes：主题文件目录_config.yml：全局配置文件，大多数的设置都在这里package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 Hexo原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使在线生成了README .md，它也会在你下一次部署时被删去。怎么解决呢？在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。 hexo博客更新博文123hexo g # 初始化文件hexo s # 本地部署hexo d # 发布到github 先记录到这，一会出现问题都会在这里更新。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ddctf解题记录]]></title>
    <url>%2F2019%2F04%2F16%2Fddctf%2F</url>
    <content type="text"><![CDATA[reverse 1使用ollydbg调试这个题就是字符串替换也可以写一个脚本在ascii码的十六进制直接做运算，我这里为了速度快直接输入存在的ascii字符的 一一对应这道题需要配置的是DDCTF{reverseME} 找到对应的一一匹配就是flag=&lt;;:9876543210/.-,+*)(‘&amp;%$][ZYXWVUTSRQPONMLKJIHGFEDCBA”abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ[]“ abcdefghijklmdcbpqrstyz#!B=&lt;;:987654321:;&lt;.-,+*%${}\ DDCTF逆向二脱壳 首先文件有一层asp壳 由于只是业余逆向就不手脱了，用ASPack Stripper这个工具 总体分析脱完壳拉进ollydbg进行调试首先总结初步调试的 输入字符数是偶数输入的字符57 - 65 &gt;48 &lt;70可以输入ABCDEF1234567890 最后将输入的值进行转换后与reverse+进行比较 python模块itertools的排列组合函数模拟所有输入的所有情况 输入测试以下是几组测试输入的值转换后的变化情况 1234567890EjRWeJA= 1234567890ABCDEFEjrWeJCrze8= FEDCBA0987654321/ty6CYdlQyE= 逆向分析使用0x401240这个函数对输入过滤 接着单步往下执行发现输入的字符主要在这个函数进行变换步入进去这个函数 将计算数来的值在0x403020里面对应找到的值再与0x76异或解析出来是 最后将转换完的字符串与reverse+比较 多次测试最后总结 这个循环的输入是6个字符串为一组。输出是4个字符串所以我们输入是十二个字符 题解奉上12345678910111213141516171819202122232425262728293031import itertoolscover = [0x37,0x34,0x35,0x32,0x33,0x30,0x31,0x3E,0x3F,0x3C,0x3D,0x3A,0x3B,0x38,0x39,0x26,0x27,0x24,0x25,0x22,0x23,0x20,0x21,0x2E,0x2F,0x2C,0x17,0x14,0x15,0x12,0x13,0x10,0x11,0x1E,0x1F,0x1C,0x1D,0x1A,0x1B,0x18,0x19,0x06,0x07,0x04,0x05,0x02,0x03,0x00,0x01,0x0E,0x0F,0x0C,0x46,0x47,0x44,0x45,0x42,0x43,0x40,0x41,0x4E,0x4F,0x5D,0x59,0x01,0x00,0x00,0x00,0xF8,0x1B,0x2B,0x00,0xB8,0x2E,0x2B,0x00]cc = ""input_ = list(itertools.product([1,2,3,4,5,6,7,8,9,"A","B","C","D","E","F"],repeat = 6))for i in range(len(input_)): a = int(str(input_[i][0])+str(input_[i][1]),16) one = a&gt;&gt;0x2 b = int(str(input_[i][2])+str(input_[i][3]),16) tmp = (a&amp;0x3)&lt;&lt;0x4 tmp_1 = b&gt;&gt;0x4 two = tmp_1+tmp c = int(str(input_[i][4])+str(input_[i][5]),16) tmp_2 = ((b&amp;0xF)*2)*2 tmp_3 = c&gt;&gt;0x6 three = tmp_2+tmp_3 four = c&amp;0x3F fuzz = chr(cover[one]^0x76) + chr(cover[two]^0x76) + chr(cover[three]^0x76) + chr(cover[four]^0x76) if(fuzz =="reve" or fuzz =="rse+"): print str(hex(a))+str(hex(b))+str(hex(c))]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用ssh反向代理+nginx实现外网连接内网服务器]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%BD%BF%E7%94%A8ssh%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2Bnginx%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91%E8%BF%9E%E6%8E%A5%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一.准备条件机器 -ip-用户-主机名-备注A -10.10.10.128 - root www - 位于内网的目标服务器B -123.123.123.123 -root vultr - 位于公网的服务器C - 192.168.1.1 - root - 123- 可以 访问公网的客户机 二.方案简单的说：在A机器上做到B机器的反向代理，将A机器上的服务端口映射到B机器的本地端口，然后使用nginx实现将本地端口转发到80(http)服务端口。 1.前提在AB机器上安装好ssh客户端和服务端 ，机器c上装上浏览器在B机器上装好nginx，测试使用完好 2.需要使用的ssh参数反向代理 -fCNR ```1正向代理```ssh -fCNL 123456-f 后台执行ssh指令-C 允许压缩数据-N 不执行远程指令-R 将远程主机(服务器)的某个端口转发到本地主机指定的端口-L 将本地机(客户机)的某个端口转发到远端指定机器的指定端口-p 指定远程主机的端口 3.建立A到B的反向代理1ssh -fCNR [B机器IP或省略]:[B机器端口]:[A机器的IP]:[A机器的sshd端口] [登录B机器的用户名@B机器的IP] -p [B机器的sshd端口] A机器的服务端口是4000，反向代理到B机器的4001端口，在A机器上操作：1ssh -fCNR 4001:localhost:4000 -o ServerAliveInterval=60 root@123.123.123.123 -p 22 注：-o ServerAliveInterval=60表示服务器B每隔60秒发送一次数据给服务器A，以便ssh连接不会因为超时而断开连接.然后这里之前要先实现A机器到B机器的ssh免密码登录，检查是否成功建立连接可以在A机器上localhost:4001```或者是可以```netstat -antpul |grep '127.0.0.1:4001'```来确认机器A到B的反向连接是否建立成功。123#### 4.使用nginx实现本地端口的转发在A机器上 ```vim /etc/nginx/nginx.conf 将下面配置信息添加到上面1234567location / &#123; proxy_pass http://localhost:4000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect off; &#125; 然后启动nginx，就可以成功将内网服务搭载公网了，使用C机器访问公网ip，这里还有就是一定要注意配置防火墙规则等。12systemctl start nginxsystemctl enable nginx 本文主要引用这个博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[记一次将ctfd搭建到校园网的centos主机上]]></title>
    <url>%2F2018%2F11%2F30%2Fctfd%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[看见其他学校的大佬都给学校搭建训练平台，羡慕不已，故我也搭一个练练手 嘻嘻。。 ctfd的搭建环境准备1yum install -y git nginx mariadb mariadb-server Mysql-python python-pip 打开mariadb1systemctl start mariadb 设置密码1mysql_secure_installation 下载设置ctfd框架1git clone https://github.com/isislab/CTFd.git 这里可能需要翻墙。。 下载完后进入到CTFd目录12./prepare.shpython3 serve.py # 如果出现缺少库的话pip install安装相应的库 我看其他教程还要： 找到SQLALCHEMY_DATABASE_URI这一参数，然后更改为：SQLALCHEMY_DATABASE_URI = ‘mysql://root:你的密码@localhost/CTFd?charset=utf8’找到HOST参数，更改为HOST = “你的服务器IP” 但是我并没有做好像直接接就成功了 ~(≧▽≦)/~。。然后可以在MySQL里看到出现CTFd的数据库 然后在当前目录下运行1gunicorn --bind 0.0.0.0:4000 -w 1 "CTFd:create_app()" 在成功后，访问你的IP:4000就可以看到网页了，如果发现访问不了，看下你的防火墙，或者安全组配置里是否开启了相应端口 配置nginx弄完CTFd后访问，我发现，巨卡，是真的卡，于是想到把最近学到nginx加上，好了许多1vim /etc/nginx/nginx.conf 修改1234567891011location /&#123;proxy_pass http://localhost:4000;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_redirect off;&#125; 设置完成123456nginx -t # 检测语法nginx -s reload # 重载systemctl enable nginxsystemctl enable mariabdsystemctl start nginx gunicorn --bind 0.0.0.0:4000 -w 1 "CTFd:create_app()" 最后一定要配置要防火墙安全策略之类的东西firewall-cmd –add-port=4000/tcp –permanent ##永久添加80端口流畅了吧，兄弟 ●０● 。这个gunicorn的命令一定要进CTFd目录输入ojbk ^O^]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf交流群的加群题]]></title>
    <url>%2F2018%2F11%2F01%2Fctf%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%85%A5%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[misc题目下载Tips：https://processor.pub/2017/03/22/0CTF-2017-python%E9%80%86%E5%90%91/ 题目中有一个pyc文件先用Easy Python Decompiler将文件反编译 123456789101112131415161718192021222324252627282930313233343536# Embedded file name: test.pyimport base64part_1 = 'cmFnZVq'part_2 = '95b3Vy'part_3 = 'X2RyZWFt'part_4 = 'ISEh'def decode--- This code section failed: ---0 LOAD_GLOBAL None3 &lt;153&gt; None6 SLICE+2 None7 &lt;151&gt; None10 BINARY_ADD None11 &lt;151&gt; None14 BINARY_ADD None15 &lt;151&gt; None18 &lt;153&gt; None21 BINARY_MULTIPLY None22 BINARY_ADD None23 STORE_FAST 'secret'26 &lt;151&gt; None29 LOAD_ATTR 'b64decode'32 LOAD_FAST 'secret'35 CALL_FUNCTION_1 None38 STORE_FAST 'text'41 LOAD_FAST 'text'44 PRINT_ITEM None45 PRINT_NEWLINE_CONT None46 &lt;153&gt; None49 RETURN_VALUE None-1 RETURN_LAST NoneSyntax error at or near `&lt;151&gt;' token at offset 0 可见有两个指令是不能识别用python中的dis，和marshal 进行调试发现文件的前四位是magic number，用来识别python版本，接着的四位为时间戳123456&gt;&gt;&gt; import dis,marshal&gt;&gt;&gt; f=open("/opt/crypt.pyc")&gt;&gt;&gt; f.read(4)'\x03\xf3\r\n'&gt;&gt;&gt; f.read(4)'\xf6\xa1$[' 接下来是读取opcode，发现opcode逻辑不对，所以修改opcode来还原函数算法。123456789101112131415161718192021222324252627&gt;&gt;&gt; code = marshal.load(f)&gt;&gt;&gt; code.co_consts(-1, None, 'cmFnZVq', '95b3Vy', 'X2RyZWFt', 'ISEh', &lt;code object decode at 0x7fb03916ca30, file "test.py", line 14&gt;)&gt;&gt;&gt; dec = code.co_consts[6]&gt;&gt;&gt; dis.dis(dec.co_code) 0 &lt;151&gt; 0 3 &lt;153&gt; 1 6 SLICE+2 7 &lt;151&gt; 1 10 BINARY_ADD 11 &lt;151&gt; 2 14 BINARY_ADD 15 &lt;151&gt; 3 18 &lt;153&gt; 2 21 BINARY_MULTIPLY 22 BINARY_ADD 23 STORE_FAST 0 (0) 26 &lt;151&gt; 4 29 LOAD_ATTR 5 (5) 32 LOAD_FAST 0 (0) 35 CALL_FUNCTION 1 38 STORE_FAST 1 (1) 41 LOAD_FAST 1 (1) 44 PRINT_ITEM 45 PRINT_NEWLINE 46 &lt;153&gt; 0 49 RETURN_VALUE 然后查看有关函数的信息123456&gt;&gt;&gt; dec.co_names('part_1', 'part_2', 'part_3', 'part_4', 'base64', 'b64decode')&gt;&gt;&gt; dec.co_varnames('secret', 'text')&gt;&gt;&gt; dec.co_consts(None, -1, 2) 发现这个指令使用的传入值0，1，2，3，4。而part的几个值是在函数的外面，猜想是LOAD_GLOBAL这个指令，这个指令使用传入的值0，1，2. 调用的是varnames的值。猜想是LOAD_CONST指令，参考：https://github.com/python/cpython/blob/master/Include/opcode.hhttps://docs.python.org/2/library/dis.html#opcode-BUILD_SET读常量用的是“100”，而里面是“153”，读取全局变量是“116”使用：1234567891011121314151617181920212223&gt;&gt;&gt; dis.dis(dec.co_code.replace("\x99","\x64").replace("\x97","\x74")) 0 LOAD_GLOBAL 0 (0) 3 LOAD_CONST 1 (1) 6 SLICE+2 7 LOAD_GLOBAL 1 (1) 10 BINARY_ADD 11 LOAD_GLOBAL 2 (2) 14 BINARY_ADD 15 LOAD_GLOBAL 3 (3) 18 LOAD_CONST 2 (2) 21 BINARY_MULTIPLY 22 BINARY_ADD 23 STORE_FAST 0 (0) 26 LOAD_GLOBAL 4 (4) 29 LOAD_ATTR 5 (5) 32 LOAD_FAST 0 (0) 35 CALL_FUNCTION 1 38 STORE_FAST 1 (1) 41 LOAD_FAST 1 (1) 44 PRINT_ITEM 45 PRINT_NEWLINE 46 LOAD_CONST 0 (0) 49 RETURN_VALUE 参考：http://anhkgg.com/python-bytecode/还原程序的加密部分：1234decode() secret=part_1[:-1]+part_2+part_3+part_4 text=b64decode(secret) return test payload.py12345678910import base64part_1 = 'cmFnZVq'part_2 = '95b3Vy'part_3 = 'X2RyZWFt'part_4 = 'ISEh'secret=part_1[:-1]+part_2+part_3+part_4text=base64.b64decode(secret)print(text) 解密得到rage_your_dream!!! 其他题期待更新。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Panther ctf]]></title>
    <url>%2F2018%2F10%2F08%2FPanther%20CTF%2F</url>
    <content type="text"><![CDATA[前言第一次写writeup开始记录在我的博客这次没有做一道题就写writeup所以有些题忘了，下次比赛一定做一道写一道writeup misc你会解压吗flag99.zip1234567#!/bin/bashfor i in &#123;1..100&#125;dox=$((100-$i))unzip ./flag$x.zipdone zzzzip?flag.zip 用ziperello爆破出5位的密码然后用十六进制编辑器发现flag So many flag!lag .txt 123456789101112131415import refile=open("E:\\flag.txt",mode="r")flag=file.read()flag1=re.split(r"&#125;pctf&#123;",flag)for i in flag1: # print(i) if len(i)==20: a=re.match(r"^[a-z][A-Z][0-9].+[a-z][A-Z][a-z]$",i) print(a) print(i)# print(flag1)file.close() 出题人的心思题目是一张jpg图片用binwalk打开发现还有一张png图片然后用kali自带的分离工具将图片分开，再用十六进制改变png图片的高度，看到flag cryptojust so so!题目描述: 密文：706374667b686868685f546831735f4833785f636f64657d 答案格式: pctf{xxxxxxxxxxxxx} 12345678import reab="70,63,74,66,7b,68,68,68,68,5f,54,68,31,73,5f,48,33,78,5f,63,6f,64,65,7d"ac=re.split(",","70,63,74,66,7b,68,68,68,68,5f,54,68,31,73,5f,48,33,78,5f,63,6f,64,65,7d")print(ac)for i in ac: print(chr(eval(i))) pctf{hhhh_Th1S_H3x_code} 被加密了的flag题目描述: cpgs{Gu1f_1F_Ebg_1r} 答案格式: pctf{xxxxxxxxxxxxx} 忘记细节了，思路是26个字母表中间对折然后替换相应的字母就转换出pctf了 My math is very poor题目描述:123456789101112131415161718192021#!/usr/bin/env python# -*- coding:utf8 -*-data = 'abcdefghijklmnopqrstuvwxyz'flag = [] #[x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x]a = 9b = 13assert len(flag) == 17def encrypt(): print 'Encrypt : ', enc = '' enc_array = [] for i in range(0,len(flag)): tmp=(a*flag[i]+b)%26 enc_array.append(tmp) enc += data[tmp] print enc # yyynvjlpjccyxginp print enc_array |# [24,24,24,13,21,9,11,15,9,2,2,24,23,6,8,13,15]if __name__ == '__main__': encrypt() 答案格式: pctf{xxxxxxxxxxxxx} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 -*- coding: utf-8 -*-from string import ascii_lowercase as lowercasefrom string import ascii_uppercase as uppercasefrequencyTable = [4, 19, 14, 0, 13, 8, 17, 18, 7, 3, \ 11, 2, 20, 12, 15, 24, 22, 6, 1, 21, \ 10, 23, 9, 16, 25]# 删除预留的标点# 文本过滤def text_filter(text): text = text.lower() result = "" for i in range(len(text)): if lowercase.find(text[i]) != -1: result += text[i] return result# 加密部分def encryption(plaintext, k1, k2): plaintext = text_filter(plaintext) result = "" for i in range(len(plaintext)): index = lowercase.find(plaintext[i]) c_index = (k1 * index + k2) % 26 result += uppercase[c_index] return result# 解密部分def get_inverse(a, b): """ #求a关于模b的逆元 """ if (a == 1 and b == 0): x = 1 y = 0 return x, y else: xx, yy = get_inverse(b, a % b) x = yy y = xx - a // b * yy return x, ydef Decryption(k1, k2, ciphertext): k3 = get_inverse(k1, 26)[0] result = "" for i in range(len(ciphertext)): index = lowercase.find(ciphertext[i]) p_index = k3 * (index - k2) % 26 result += lowercase[p_index] return resultif __name__ == '__main__': ciphertext = "yyynvjlpjccyxginp" print(Decryption(9,13,ciphertext)) 仿射密码看这个博客的 其他题我也忘了。。。 reverse软件破解第一步Reverse11.exe 用ida打开就有flag了嘿嘿 come on!flag_file.pyo 这是一个Python的编译后加了防反编译模块用 easy Python Decompiler这个工具解开就可以看到源码 1234567891011121314151617181920212223# Embedded file name: /home/sliver/Documents/CTF/Python/python.pyimport base64import py_compilepy_compile.compile('/home/sliver/Documents/CTF/Python/python.py')def encode(message): s = '' for i in message: x = ord(i) x = x - 16 s += chr(x) return base64.b64encode(s)correct = 'RFhZJU8hY09AaU9DZlJaVVNk'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct,this is my flag'else: print 'wrong' 然后用 123456s="p"for i in "RFhZJU8hY09AaU9DZlJaVVNk": x=ord(i) x=x+16 s+=chr(x)print(s) 就可见flag input flagReverse3.exe用ida打开f5大法 发现DXY%O!cO@iOCfRZUSd 对flag进行处理后与这个字符串进行比较123456s="p"for i in "DXY%O!cO@iOCfRZUSd": x=ord(i) x=x+16 s+=chr(x)print(s) 可解出flag web为什么这么简单答案格式: pctf{xxxxxxxxxxxxx} 题目链接: 题目链接 [题目链接]http://47.94.4.84/web/web1abf20c91a442da48.php 用hackbar post一个比66666大的数 （最快的方法了） i’m so sadhttp://101.200.58.30/test1.php base64对字符串解码可看到代码发送get请求a[]=1$b[]=2 得到flag php is best language!http://47.94.4.84/web/web25d47c5d8a6299792.php 用hackbar postmagic_keys[]=1可得flag pctf结束]]></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.4安装一些软件时出现 Unable to correct problems, you have held broken packages]]></title>
    <url>%2F2018%2F06%2F09%2F%E8%A7%A3%E5%86%B3%E5%8C%85%E6%8D%9F%E5%9D%8F%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[这几天在看《揭秘家用路由器0day漏洞挖掘技术》下了ubuntu18.4，感觉Ubuntu还是不错的，发现没有Python2（mmp），安装是出现了Unable to correct problems, you have held broken packages问题（附图一张） 12345678910111213Reading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: python : PreDepends: python-minimal (= 2.7.12-1~16.04) but it is not going to be installed Depends: python2.7 (&gt;= 2.7.12-1~) but it is not going to be installedE: Unable to correct problems, you have held broken packages. 查了百度许多资料都是这么说 123$ sudo apt-get upgrade$ sudo apt-get update 后来从这里他这上面说aptitude解决，尝试后发现安装这个也有相同的问题，于是又用了下面的方法，成功了。下面分享给大家： 用这条命令看你损坏的包然后卸载了123456#查看包dpkg --get-selections | grep python#卸载sudo apt-get remove libpython2.7sudo apt-get remove libpython2.7-minimalsudo apt-get remove libpython2.7-stdlib 把有关的包都卸载了，让后再1sudo apt-get insatll python 我这里的python是其中一个出现问题的，如果童鞋在安装软件是出现这个错误按这个方法处理。]]></content>
  </entry>
</search>
